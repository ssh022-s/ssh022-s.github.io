<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Policy Gradient Algorithms | Shihao Sun </title> <meta name="author" content="Shihao Sun"> <meta name="description" content="Introduce Policy Gradient Algorithms includes VPG, PPO, A3C, DDPG, TD3, SAC."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ssh022-s.github.io/blog/2020/6pga/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Shihao</span> Sun </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Policy Gradient Algorithms</h1> <p class="post-meta"> Created in December 26, 2020 </p> <p class="post-tags"> <a href="/blog/2020"> <i class="fa-solid fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/category/rl"> <i class="fa-solid fa-tag fa-sm"></i> RL</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="vpg">VPG</h2> <p><strong>Policy Optimization.</strong> Methods in this family represent a policy explicitly as $\pi_\theta(a|s)$. They optimize the parameters $\theta$ either directly by gradient ascent on the performance objective $J(\pi_\theta)$, or indirectly, by maximizing local approximations of $J(\pi_\theta)$.</p> <p>The performance objective $J(\pi_\theta)$ here is the reward. The reward function is defined as:</p> \[J(\theta) = \sum_{s \in S}d^\pi(s)V^\pi(s) = \sum_{s \in S}d^\pi(s)\sum_{a \in A}\pi_\theta(a|s)Q^\pi(s, a)\] <p>where $d^\pi(s)$ is the stationary distribution of Markov chain for $\pi_\theta$ (on-policy state distribution under $\pi$).</p> <p>Using <em>gradient ascent</em>, we can move θ toward the direction suggested by the gradient $\nabla_\theta J(\theta)$ to find the best θ for $\pi_\theta$ that produces the highest return.</p> <p>VPG Key Equations:</p> <p>The gradient of $J(\theta)$ is</p> \[\nabla_\theta J(\pi_\theta) = \Bbb E_{\pi_\theta}[\nabla_\theta\log{\pi_\theta}(s,a)Q^{\pi_\theta}(s,a)]\] \[\nabla_\theta J(\pi_\theta) =\underset {\tau \sim \pi_\theta} {\Bbb E}[\overset T {\underset {t=0} \sum} \nabla_\theta \log \pi_\theta(a_t|s_t)A^{\pi_\theta}(s_t, a_t)]\] <p>This optimization is almost always performed <strong>on-policy</strong>, which means that each update only uses data collected while acting according to the most recent version of the policy. Policy optimization also usually involves learning an approximator $V_\phi(s)$ for the on-policy value function $V^\pi(s)$, which gets used in figuring out how to update the policy.</p> <p>Policy-based reinforcement learning method Ada:</p> <ul> <li>better convergence properties, just follow the gradient to find the best parameters</li> <li>more effective in high dimensional action spaces</li> <li>can learn stochastic policies, We also get rid of the problem of perceptual aliasing. Perceptual aliasing is when we have two states that seem to be (or actually are) the same, but need different actions.</li> </ul> <p>Dis:</p> <ul> <li> <p>Need a lot of the time, they converge on a local maximum rather than on the global optimum.</p> <p>Solutions: Policy Search</p> </li> </ul> <p>In practice, $V^\pi(s_t)$ cannot be computed exactly, so it has to be approximated. This is usually done with a neural network, $V_\phi(s_t)$, which is updated concurrently with the policy (so that the value network always approximates the value function of the most recent policy).</p> <p>The simplest method for learning , used in most implementations of policy optimization algorithms (including VPG, TRPO, PPO, and A2C), is to minimize a mean-squared-error objective:</p> \[\phi_k = \arg\underset \phi \min \underset {s_t, \hat R_t \sim \pi_k} E [(V_\phi(s_t)-\hat R_t)^2]\] <hr> <h2 id="ppo">PPO</h2> <p>PPO is motivated by the same question as TRPO: how can we take the biggest possible improvement step on a policy using the data we currently have, without stepping so far that we accidentally cause performance collapse?</p> <p>PPO-Clip doesn’t have a KL-divergence term in the objective and doesn’t have a constraint at all. Instead relies on specialized clipping in the objective function to remove incentives for the new policy to get far from the old policy.</p> <p>PPO-clip updates policies via (by maximizing the objective)</p> \[\theta_{k+1} = \arg \underset \theta \max \underset {s, a \sim \pi_{\theta_k}} E[L(s, a, \theta_k, \theta)]\] <p>$\epsilon$ is a (small) hyperparameter which roughly says how far away the new policy is allowed to go from the old.</p> <p>$L(s, a, \theta_k, \theta)$ is the PPO-Clip objective function:</p> \[L(s,a,\theta_k,\theta) = \min(\frac {\pi_\theta(a|s)} {\pi_{\theta_k}(a|s)}A^{\pi_{\theta_k}}(s,a), g(\epsilon, A^{\pi_{\theta_k}}(s,a))\\ where \ g(\epsilon, A) = \begin{cases} (1+\epsilon)A &amp; {A \geq 0} \\ (1-\epsilon)A &amp; A &lt; 0 \end{cases}\] <p>Cause we want reuse data collect by old policy(after once gradient ascent, the police collected data became old policy). We use Importance sampling to enable use data from different policy.</p> <p>Importance sampling function: $E_{x\sim p}[f(x)] = E_{x\sim p}[\frac {p(x)} {q(x)} f(x)]$. This is where $\frac {\pi_\theta(a|s)} {\pi_{\theta_k}(a|s)}A^{\pi_{\theta_k}}(s,a)$ come from.</p> <p><strong>Advantage is positive</strong>: Suppose the advantage for that state-action pair is positive, in which case its contribution to the objective reduces to</p> \[A \geq 0 \ L(s,a,\theta_k,\theta) = \min(\frac {\pi_\theta(a|s)} {\pi_{\theta_k}(a|s)}, (1+\epsilon))A^{\pi_{\theta_k}}(s,a)\] <p>Advantage is positive which means this action a under state s is better than others. So we want increase this action’s probability under state s. But the probability incensement can’t great than (1+$\epsilon$).</p> <p><strong>Advantage is negative</strong>: Suppose the advantage for that state-action pair is negative, in which case its contribution to the objective reduces to</p> \[A &lt; 0 \ L(s,a,\theta_k,\theta) = \min(\frac {\pi_\theta(a|s)} {\pi_{\theta_k}(a|s)}, (1-\epsilon))A^{\pi_{\theta_k}}(s,a)\] <p>Advantage is negative which means this action a under state s is worse than others. So we want decrease this action’s probability under state s. But the probability decrement can’t less than (1+$\epsilon$).</p> <p>SPPO</p> \[L(s,a,\theta_k,\theta) = \min(\frac {\pi_\theta(a|s)} {\pi_{\theta_k}(a|s)}A^{\pi_{\theta_k}}(s,a), g(\epsilon, A^{\pi_{\theta_k}}(s,a)) + \alpha \pi_\theta(\widetilde a|s) \log \pi_\theta(\widetilde a|s)\\ where \ g(\epsilon, A) = \begin{cases} (1+\epsilon)A &amp; {A \geq 0} \\ (1-\epsilon)A &amp; A &lt; 0 \end{cases}\] <hr> <h2 id="a3c">A3C</h2> <p>Deep neural networks provide rich representations that can enable reinforcement learning (RL) algorithms to perform effectively.</p> <p>the combination of simple online RL algorithms with DNN was fundamentally unstable.</p> <p>Why?</p> <p>the sequence of observed data encountered by an online RL agent is non-stationary, and online RL updates are strongly correlated.</p> <p>Solution: Replay buffer</p> <p>the data can be batched or randomly sampled from different time-steps.</p> <p>reduce non-stationarity and decorrelates updates.</p> <p>Drawbacks:</p> <p>Limits the methods to off-policy RL algorithms.</p> <p>It uses more memory and computation per real interaction</p> <p>This paper:</p> <p>Idea: asynchronously execute multiple agents in parallel, on multiple instances of the environment.</p> <p>enables on-policy and off-policy RL algorithms.</p> <p>run on multi-core CPU. using far less resource.</p> <p>Asynchronous RL Framework</p> <p>multi-threaded asynchronous variants of one-step Sarsa, one-step Q-learning, n-step Q-learning, and advantage actor-critic.</p> <p>two main ideas:</p> <p>First, asynchronous actor-learners, use multiple CPU threads on a single machine.</p> <p>Second, we make the observation that multiple actors-learners running in parallel are likely to be exploring different parts of the environment.</p> <p>Asynchronous advantage actor-critic:</p> <p>We typically use a convolutional neural network that has one softmax output for the policy $\pi(a_t|s_t;\theta)$ and one linear output for the value function $V(s_t;\theta_v)$, with all non-output layers shared.</p> <p>We also found that adding the entropy of the policy $\pi$ to the objective function improved exploration by discouraging premature convergence to suboptimal deterministic policies.</p> <p>asynchronous advantage actor-critic (A3C), maintains a policy $\pi(a_t|s_t;\theta)$ and an estimate of the value function $V(s_t; \theta_v)$. uses the same mix of n-step returns to update both the policy and the value-function. The policy and the value function are updated after every $t_\max$ actions or when a terminal state is reached. The update performed by the algorithm can be seen as $\nabla_{\theta’} \log\pi(a_t | s_t; \theta’)A(s_t, a_t; \theta, \theta_v)$</p> <p>where $A(s_t, a_t;\theta, \theta_v)$ is an estimate of the advantage function given by $\sum_{i=0}^{k-1} \gamma^i r_{t+i} + \gamma^kV(s_{t+k};\theta_v)−V(s_t;\theta_v)$</p> <p>A*3</p> <p><strong>Asynchronous</strong>: Unlike DQN, where a single agent represented by a single neural network interacts with a single environment, A3C utilizes multiple incarnations of the above in order to learn more efficiently. In A3C there is a global network, and multiple worker agents which each have their own set of network parameters. Each of these agents interacts with it’s own copy of the environment at the same time as the other agents are interacting with their environments. The reason this works better than having a single agent (beyond the speedup of getting more work done), is that the experience of each agent is independent of the experience of the others. In this way the overall experience available for training becomes more diverse.</p> <p><strong>Actor-Critic</strong>: Actor-Critic combines the benefits of Q-learning and Policy Gradient approaches. In the case of A3C, our network will estimate both a value function <strong>V(s)</strong> (how good a certain state is to be in) and a policy <strong>π(s)</strong> (a set of action probability outputs). These will each be separate fully-connected layers sitting at the top of the network. <strong>Critically, the agent uses the value estimate (the critic) to update the policy (the actor) more intelligently than traditional policy gradient methods.</strong></p> <p><strong>Advantage</strong>: $A = Q(s, a) - V(s)$. Since we won’t be determining the Q values directly in A3C, we can use the discounted returns (R) as an estimate of Q(s,a) to allow us to generate an estimate of the advantage: $A = R - V(s), R = \gamma(r)$</p> <hr> <h2 id="ddpg-td3">DDPG, TD3</h2> <h3 id="the-optimal-q-function-and-the-optimal-action">The Optimal Q-Function and the Optimal Action</h3> <p>There is an important connection between the optimal action-value function $Q^*(s, a)$ and the action selected by the optimal policy. By definition, $Q^*(s, a)$ gives the expected return for starting in state $s$, taking (arbitrary) action $a$, and then acting according to the optimal policy forever after.</p> <p>The optimal policy in $s$ will select whichever action maximizes the expected return from starting in $s$. As a result, if we have $Q^*$, we can directly obtain the optimal action, $a^*(s)$, via</p> <p>$a^*(s) = \arg \max_aQ^*(s, a)$</p> <p>Note: there may be multiple actions which maximize $Q^*(s, a)$, in which case, all of them are optimal, and the optimal policy may randomly select any of them. But there is always an optimal policy which deterministically selects an action.</p> <h3 id="ddpg">DDPG</h3> <p>Deep Deterministic Policy Gradient (DDPG) is an algorithm which concurrently learns a Q-function and a policy. <strong>It uses off-policy data and the Bellman equation to learn the Q-function, and uses the Q-function to learn the policy.</strong></p> <p>Because the action space is continuous, the function $Q^*(s, a)$ is presumed to be differentiable with respect to the action argument. This allows us to set up an efficient, gradient-based learning rule for a policy $\mu(s)$ which exploits that fact. Then, instead of running an expensive optimization subroutine each time we wish to compute $\max_aQ(s, a)$, we can approximate it with $\max_aQ(s, a) \approx Q(s, \mu(s))$.</p> <p>The Q-Learning Side of DDPG</p> <p>Loss function: <strong>mean-squared Bellman error (MSBE)</strong></p> <p>$L(\phi, D) = E_{(s, a, r, s’, d)\sim D}\left[\left(Q_\phi(s, a)-(r+\gamma(1-d)\max_{a’}Q_\phi(s’, a’))\right)^2\right]$</p> <p>d mean done, if d = 1 (True), s’ is a terminal state.</p> <p>Q-learning algorithms for function approximators, such as DQN (and all its variants) and DDPG, are largely based on minimizing this MSBE loss function.</p> <p>It uses off-policy data and the Bellman equation to learn the Q-function,</p> <p>Again, we can’t compute the $\max_{a’}Q_\phi(s’, a’)$ in continuous action spaces. So we use a <strong>target policy network</strong> to compute an action.</p> <p>The Policy Learning Side of DDPG</p> <p>$L(\phi, D) = E_{(s, a, r, s’, d)\sim D}\left[\left(Q_\phi(s, a)-(r+\gamma(1-d)Q_{\phi_{targ}}(s’, \mu_{\theta_{targ}}(s’)))\right)^2\right]$</p> <p>where $\mu_{\theta_{targ}}$ is the target policy.</p> <p>Policy learning in DDPG is fairly simple. We want to learn a deterministic policy $\mu_\theta(s)$ which gives the action that maximizes $Q_\phi(s, a)$. Because the action space is continuous, and we assume the Q-function is differentiable with respect to action, we can just perform gradient ascent (with respect to policy parameters only) to solve $\max_\theta E_{s\sim D}[Q_\phi(s, \mu_\theta(s))].$</p> <p>Note that the Q-function parameters are treated as constants here.</p> <p>Tricks:</p> <ul> <li> <strong>Target Networks.</strong> Q-learning algorithms make use of <strong>target networks</strong>.</li> <li> <strong>Replay Buffers.</strong> All standard algorithms for training a deep neural network to approximate $Q^*(s, a)$ make use of an experience replay buffer.</li> <li> <strong>OU noise.</strong> To make DDPG policies explore better, we add noise to their actions at training time. The authors of the original DDPG paper recommended time-correlated OU noise, but more recent results suggest that uncorrelated, mean-zero Gaussian noise works perfectly well.</li> <li>For exploration at the start of training. For a fixed number of steps at the beginning (set with the <code class="language-plaintext highlighter-rouge">start_steps</code> keyword argument), the agent takes actions which are sampled from a uniform random distribution over valid actions. After that, it returns to normal DDPG exploration.</li> </ul> <h3 id="td3">TD3</h3> <p><strong>Trick One: Clipped Double-Q Learning.</strong> TD3 learns <em>two</em> Q-functions instead of one (hence “twin”), and uses the smaller of the two Q-values to form the targets in the Bellman error loss functions.</p> <p><strong>Trick Two: “Delayed” Policy Updates.</strong> TD3 updates the policy (and target networks) less frequently than the Q-function. The paper recommends one policy update for every two Q-function updates.</p> <p><strong>Trick Three: Target Policy Smoothing.</strong> TD3 adds noise to the target action, to make it harder for the policy to exploit Q-function errors by smoothing out Q along changes in action.</p> <p>Together, these three tricks result in substantially improved performance over baseline DDPG.</p> <p>TD3 trains a deterministic policy in an off-policy way. To make TD3 policies explore better, we add noise to their actions at training time, typically uncorrelated mean-zero Gaussian noise.</p> <p>For exploration at the start of training. For a fixed number of steps at the beginning (set with the <code class="language-plaintext highlighter-rouge">start_steps</code> keyword argument), the agent takes actions which are sampled from a uniform random distribution over valid actions. After that, it returns to normal TD3 exploration.</p> <hr> <h3 id="sac">SAC</h3> <p>A central feature of SAC is <strong>entropy regularization.</strong> The policy is trained to maximize a trade-off between expected return and entropy, a measure of randomness in the policy.</p> <p><strong>Entropy-Regularized Reinforcement Learning</strong></p> <p>Let $x$ be a random variable with probability mass or density function $P$. The entropy $H$ of $x$ is computed from its distribution $P$ according to</p> \[H(P) = \underset {x \sim P} E[-\log P(x)].\] <p>The RL problem now:</p> \[\pi^* = \arg \underset \pi \max \underset {\tau \sim \pi} E\left[\overset \infty {\underset {t=0} \sum}\gamma^t\left(R(s_t, a_t, s_{t+1})+\alpha H(\pi(\cdot|s_t))\right) \right]\] <p>where $\alpha &gt; 0$ is the trade-off coefficient.</p> <p>$V^\pi$ is changed to include the entropy bonuses from every timestep:</p> \[V^\pi(s) = \underset {\tau \sim \pi} E \left[\overset \infty {\underset {t=0} \sum}\gamma^t\left(R(s_t, a_t, s_{t+1})+\alpha H(\pi(\cdot|s_t)) \right)|s_0=s \right]\] <p>$Q^\pi$ is changed to include the entropy bonuses from every timestep <em>except the first</em>:</p> \[Q^\pi(s, a) = \underset {\tau \sim \pi} E \left[\overset \infty {\underset {t=0} \sum}\gamma^t R(s_t, a_t, s_{t+1})+\alpha \overset \infty {\underset {t=1} \sum}\gamma^t H(\pi(\cdot|s_t)) |s_0=s,a_0=a \right]\] <p>With these definitons, $V^\pi$ and $Q^\pi$ are connected by:</p> \[V^\pi(s) = \underset {a\sim\pi}E[Q^\pi(s,a)] + \alpha H(\pi(\cdot|s))\] <p>and the Bellman equation for $Q^\pi$ is</p> \[\begin{align} Q^\pi(s,a) &amp;= \underset {s'\sim P}E[R(s,a,s')+\gamma(Q^\pi(s',a')+\alpha H(\pi(\cdot|s')))] \\&amp;= \underset {s'\sim P}E[R(s,a,s')+\gamma V^\pi(s')]. \end{align}\] <p>The modern version that omits the extra value function:</p> <p>SAC concurrently learns a policy $\pi_\theta$ and two Q-functions $Q_{\phi_1}, Q_{\phi_2}$. There are two variants of SAC that are currently standard: one that uses a fixed entropy regularization coefficient $\alpha$, and another that enforces an entropy constraint by varying $\alpha$ over the course of training. For simplicity, Spinning Up makes use of the version with a fixed entropy regularization coefficient, but the entropy-constrained variant is generally preferred by practitioners.</p> <p><strong>Learning Q.</strong> The Q-functions are learned in a similar way to TD3, but with a few key differences.</p> <p>First, what’s similar?</p> <ol> <li>Like in TD3, both Q-functions are learned with MSBE minimization, by regressing to a single shared target.</li> <li>Like in TD3, the shared target is computed using target Q-networks, and the target Q-networks are obtained by polyak averaging the Q-network parameters over the course of training.</li> <li>Like in TD3, the shared target makes use of the <strong>clipped double-Q</strong> trick.</li> </ol> <p>What’s different?</p> <ol> <li>Unlike in TD3, the target also includes a term that comes from SAC’s use of entropy regularization.</li> <li>Unlike in TD3, the next-state actions used in the target come from the <strong>current policy</strong> instead of a target policy.</li> <li>Unlike in TD3, there is no explicit target policy smoothing. TD3 trains a deterministic policy, and so it accomplishes smoothing by adding random noise to the next-state actions. SAC trains a stochastic policy, and so the noise from that stochasticity is sufficient to get a similar effect.</li> </ol> <p>Recursive Bellman equation:</p> \[Q^\pi(s,a) = \underset {s'\sim P, a'\sim\pi} {\mathbb E}[R(s,a,s')+\gamma(Q^\pi(s',a')+\alpha H(\pi(\cdot|s')))]\\ = \underset {s'\sim P, a'\sim\pi} {\mathbb E}[R(s,a,s')+\gamma(Q^\pi(s',a')-\alpha \log\pi(a'|s'))]\] <p>The R H S is an expectation over next states (which come from the replay buffer) and next actions $\tilde a’$ (which come from the current policy). Since it’s an expectation, we can approximate it with samples:</p> \[Q^\pi(s,a) \approx r + \gamma(Q^\pi(s',\tilde a')-\alpha\log\pi(\tilde a'|s')),\tilde a'\sim \pi(\cdot|s')\] <p>the loss functions for the Q-networks in SAC:</p> \[L(\phi_i, \mathcal D) = \underset {(s,a,r,s',d)\sim \mathcal D} E[(Q_{\phi_i}(s,a)-y(r,s',d))^2],\] <p>target is:</p> \[y(r,s',d) = r + \gamma(1-d)(\underset {j=1,2} \min Q_{\phi_{targ,j}}(s',\tilde a')-\alpha\log\pi_\theta(\tilde a'|s')), \tilde a'\sim\pi_\theta(\cdot|s').\] <p><strong>Learning the Policy.</strong> The policy should, in each state, act to maximize the expected future return plus expected future entropy. That is, it should maximize $V^\pi(s)$, which we expand out into</p> \[V^\pi(s) = \underset {a\sim \pi} E[Q^\pi(s,a)]+\alpha H(\pi(\cdot|s))\\ = \underset {a\sim \pi} E[Q^\pi(s,a)-\alpha\log\pi(a|s)].\] <p>The way we optimize the policy makes use of the <strong>reparameterization trick</strong>, in which a sample from $\pi_\theta(\cdot|s)$ is drawn by computing a deterministic function of state, policy parameters, and independent noise:</p> \[\tilde a_\theta(s,\xi) = \tanh(\mu_\theta(s)+\sigma_\theta(s) \odot \xi), \xi\sim\mathcal N(0, I)\] <p>policy loss:</p> \[\underset {j=1,2} \min Q_{\phi_j}(s,\tilde a_\theta(s,\xi))-\alpha\log\pi_\theta(\tilde a_\theta(s,\xi)|s)\] <p>At test time, to see how well the policy exploits what it has learned, we remove stochasticity and use the mean action instead of a sample from the distribution. This tends to improve performance over the original stochastic policy.</p> <hr> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/7dqn/">DQN</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/5pg/">Policy Gradient Method</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/4fa/">Function Approximation</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/3mfp/">Model-Free Prediction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/2dp/">Dynamic Programming</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Shihao Sun. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-cv",title:"cv",description:"This is a description of the page. You can modify it in '_pages/cv.md'. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-dqn",title:"DQN",description:"DQN and it's improvement.",section:"Posts",handler:()=>{window.location.href="/blog/2020/7dqn/"}},{id:"post-policy-gradient-algorithms",title:"Policy Gradient Algorithms",description:"Introduce Policy Gradient Algorithms includes VPG, PPO, A3C, DDPG, TD3, SAC.",section:"Posts",handler:()=>{window.location.href="/blog/2020/6pga/"}},{id:"post-policy-gradient-method",title:"Policy Gradient Method",description:"Reinforcement Learning basic concepts",section:"Posts",handler:()=>{window.location.href="/blog/2020/5pg/"}},{id:"post-function-approximation",title:"Function Approximation",description:"Reinforcement Learning basic concepts",section:"Posts",handler:()=>{window.location.href="/blog/2020/4fa/"}},{id:"post-model-free-prediction",title:"Model-Free Prediction",description:"Reinforcement Learning basic concepts",section:"Posts",handler:()=>{window.location.href="/blog/2020/3mfp/"}},{id:"post-dynamic-programming",title:"Dynamic Programming",description:"Reinforcement Learning basic concepts",section:"Posts",handler:()=>{window.location.href="/blog/2020/2dp/"}},{id:"post-multi-armed-bandits-exploration-and-exploitation",title:"Multi-armed Bandits: exploration and exploitation",description:"Reinforcement Learning basic concepts",section:"Posts",handler:()=>{window.location.href="/blog/2020/1mab/"}},{id:"post-reinforcement-learning-basic-concepts",title:"Reinforcement Learning Basic Concepts",description:"Reinforcement Learning basic concepts and Finite Markov Decision Processes",section:"Posts",handler:()=>{window.location.href="/blog/2020/0rlbasic/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"projects-beast-engine",title:"Beast Engine",description:"AI-Native Game Engine",section:"Projects",handler:()=>{window.location.href="/projects/Beast/"}},{id:"projects-machine-learning-for-blast-performance-analysis-in-mining",title:"Machine Learning for Blast Performance Analysis in Mining",description:"Automated Blast Rating from Drone Footage",section:"Projects",handler:()=>{window.location.href="/projects/Blasting/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%32%32%39%35%35%32%39%34%38%32@%71%71.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/liushuai26","_blank")}},{id:"socials-youtube",title:"YouTube",section:"Socials",handler:()=>{window.open("https://youtube.com/@aicat-","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>